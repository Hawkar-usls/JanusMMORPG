<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>SURVIVAL CORE</title>
    <script src="https://telegram.org/js/telegram-web-app.js"></script>
    <style>
        :root { --bg: #111; --panel: #1e1e1e; --border: #444; --accent: #f0a500; --text: #eee; }
        body { margin: 0; background: var(--bg); color: var(--text); overflow: hidden; font-family: 'Courier New', monospace; touch-action: none; user-select: none; }
        canvas { display: block; image-rendering: pixelated; width: 100%; height: 100%; }

        /* UI OVERLAY */
        .ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; }
        .pointer { pointer-events: auto; }

        /* HUD */
        .hud { position: absolute; top: 10px; left: 10px; display: flex; flex-direction: column; gap: 4px; width: 120px; }
        .bar-wrap { background: #000; height: 8px; border: 1px solid #333; position: relative; }
        .bar-fill { height: 100%; transition: width 0.5s; }
        .c-hp { background: #d33; } .c-food { background: #fa0; } .c-water { background: #0af; }

        /* BOTTOM DOCK */
        .dock { position: absolute; bottom: 20px; left: 0; width: 100%; display: flex; justify-content: center; gap: 15px; pointer-events: auto; }
        .dock-btn { 
            width: 50px; height: 50px; background: var(--panel); border: 2px solid var(--border); 
            border-radius: 8px; font-size: 24px; display: flex; justify-content: center; align-items: center; 
            box-shadow: 0 4px 6px rgba(0,0,0,0.5); cursor: pointer;
        }
        .dock-btn:active { transform: scale(0.95); border-color: var(--accent); }

        /* MODALS (Inventory/Craft) */
        .modal {
            display: none; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            width: 90%; max-width: 400px; max-height: 80%; background: var(--panel); 
            border: 2px solid var(--border); box-shadow: 0 0 20px rgba(0,0,0,0.8);
            flex-direction: column; padding: 10px; border-radius: 4px; pointer-events: auto;
            z-index: 100;
        }
        .modal.open { display: flex; }
        .modal-header { display: flex; justify-content: space-between; margin-bottom: 10px; font-weight: bold; border-bottom: 1px solid var(--border); padding-bottom: 5px; }
        .close-btn { color: #f44; cursor: pointer; }

        /* GRID */
        .grid { display: grid; grid-template-columns: repeat(5, 1fr); gap: 5px; overflow-y: auto; padding: 5px; }
        .slot { 
            aspect-ratio: 1; background: #2a2a2a; border: 1px solid #333; 
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            font-size: 10px; cursor: pointer; position: relative;
        }
        .slot.selected { border-color: var(--accent); background: #333; }
        .slot img { width: 60%; image-rendering: pixelated; margin-bottom: 2px; }
        .count { position: absolute; bottom: 2px; right: 2px; color: #aaa; }

        /* ITEM DETAILS */
        .details { margin-top: 10px; padding-top: 10px; border-top: 1px solid var(--border); min-height: 60px; display: flex; flex-direction: column; gap: 5px; }
        .btn-action { background: #333; color: white; border: 1px solid #555; padding: 8px; cursor: pointer; text-align: center; }
        .btn-action.primary { background: var(--accent); color: #000; border: none; font-weight: bold; }
        .btn-action:disabled { opacity: 0.5; cursor: default; }

        /* TOAST NOTIFICATIONS */
        .toast-area { position: absolute; top: 50px; width: 100%; text-align: center; display: flex; flex-direction: column; align-items: center; gap: 5px; }
        .toast { background: rgba(0,0,0,0.7); color: #fff; padding: 5px 10px; border-radius: 4px; font-size: 12px; animation: fadeUp 2s forwards; }
        @keyframes fadeUp { 0%{opacity:1; transform:translateY(0)} 100%{opacity:0; transform:translateY(-20px)} }

        /* BUILD OVERLAY */
        #build-hint { position: absolute; top: 20px; width: 100%; text-align: center; color: #0f0; font-weight: bold; text-shadow: 1px 1px 0 #000; display: none; }
    </style>
</head>
<body>

    <canvas id="game"></canvas>

    <div class="ui-layer">
        <div class="hud pointer">
            <div class="bar-wrap"><div class="bar-fill c-hp" id="bar-hp" style="width:100%"></div></div>
            <div class="bar-wrap"><div class="bar-fill c-food" id="bar-food" style="width:100%"></div></div>
            <div class="bar-wrap"><div class="bar-fill c-water" id="bar-water" style="width:100%"></div></div>
        </div>
        
        <div class="toast-area" id="toasts"></div>
        <div id="build-hint">–†–ï–ñ–ò–ú –°–¢–†–û–ô–ö–ò: –ö–ª–∏–∫–Ω–∏ –Ω–∞ –∑–µ–º–ª—é</div>

        <div class="dock">
            <div class="dock-btn" onclick="openModal('inventory')">üéí</div>
            <div class="dock-btn" onclick="openModal('craft')">üî®</div>
            <div class="dock-btn" onclick="saveGame(); toast('–°–æ—Ö—Ä–∞–Ω–µ–Ω–æ!')">üíæ</div>
        </div>

        <div class="modal" id="modal-inventory">
            <div class="modal-header"><span>–ò–ù–í–ï–ù–¢–ê–†–¨</span> <span class="close-btn" onclick="closeModals()">‚úï</span></div>
            <div class="grid" id="inv-grid"></div>
            <div class="details" id="inv-details">
                <div style="color:#777">–í—ã–±–µ—Ä–∏—Ç–µ –ø—Ä–µ–¥–º–µ—Ç...</div>
            </div>
        </div>

        <div class="modal" id="modal-craft">
            <div class="modal-header"><span>–°–û–ó–î–ê–ù–ò–ï</span> <span class="close-btn" onclick="closeModals()">‚úï</span></div>
            <div class="grid" id="craft-grid"></div>
            <div class="details" id="craft-details"></div>
        </div>
    </div>

<script>
    // --- DATABASE ---
    const ITEMS = {
        'wood': { name: '–î–µ—Ä–µ–≤–æ', type: 'res', icon: 'üå≤' },
        'stone': { name: '–ö–∞–º–µ–Ω—å', type: 'res', icon: 'ü™®' },
        'berry': { name: '–Ø–≥–æ–¥–∞', type: 'food', val: 15, icon: 'üçí' },
        'fiber': { name: '–í–æ–ª–æ–∫–Ω–æ', type: 'res', icon: 'üåø' },
        
        'axe_stone': { name: '–ö–∞–º. –¢–æ–ø–æ—Ä', type: 'tool', slot: 'hand', icon: 'ü™ì' },
        'shirt_rag': { name: '–õ–æ—Ö–º–æ—Ç—å—è', type: 'armor', slot: 'chest', icon: 'üëï' },
        'sword_iron': { name: '–ú–µ—á', type: 'weapon', slot: 'hand', icon: '‚öîÔ∏è' },
        
        'wall_wood': { name: '–°—Ç. (–î–µ—Ä)', type: 'build', id: 101, icon: 'üß±' },
        'floor_wood': { name: '–ü–æ–ª (–î–µ—Ä)', type: 'build', id: 102, icon: '‚¨ú' },
        'campfire': { name: '–ö–æ—Å—Ç–µ—Ä', type: 'build', id: 103, icon: 'üî•' }
    };

    const RECIPES = [
        { out: 'axe_stone', n: 1, cost: { 'wood': 3, 'stone': 2 } },
        { out: 'shirt_rag', n: 1, cost: { 'fiber': 5 } },
        { out: 'sword_iron', n: 1, cost: { 'wood': 2, 'stone': 5 } }, // Simplified logic
        { out: 'wall_wood', n: 1, cost: { 'wood': 4 } },
        { out: 'floor_wood', n: 1, cost: { 'wood': 2 } },
        { out: 'campfire', n: 1, cost: { 'wood': 5, 'stone': 2 } }
    ];

    // --- ENGINE SETUP ---
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const SCALE = 3; 
    const TILE_SIZE = 16 * SCALE; 
    let camera = { x: 0, y: 0 };
    let mode = 'play'; // play, build
    let buildItem = null; // item key being built

    // --- GAME STATE ---
    let player = {
        x: 0, y: 0,
        hp: 100, food: 100, water: 100,
        inv: {}, // { 'wood': 10, 'stone': 2 }
        equip: { chest: null, hand: null },
        facing: 1
    };

    let world = {
        seed: Math.random(),
        structures: [], // {x, y, id}
        dropped: [] // {x, y, id}
    };

    // Load Save
    const save = localStorage.getItem('surv_save_v1');
    if(save) {
        const data = JSON.parse(save);
        player = data.player;
        world = data.world;
        console.log("Save loaded");
    }

    // --- LOGIC ---
    function init() {
        resize();
        window.addEventListener('resize', resize);
        
        // Input
        canvas.addEventListener('pointerdown', onPointerDown);
        
        // Loop
        requestAnimationFrame(render);
        setInterval(tick, 2000); // Slow tick for stats
    }

    function tick() {
        // Slow decay
        player.food = Math.max(0, player.food - 1);
        player.water = Math.max(0, player.water - 1.5);
        if(player.food === 0 || player.water === 0) player.hp = Math.max(0, player.hp - 1);
        
        updateHUD();
    }

    // --- MOVEMENT & INTERACTION ---
    let target = null;
    let targetAction = null; // { type: 'chop', x, y }

    function onPointerDown(e) {
        const r = canvas.getBoundingClientRect();
        const mx = e.clientX - r.left + camera.x;
        const my = e.clientY - r.top + camera.y;
        
        if(mode === 'build' && buildItem) {
            placeStructure(mx, my);
            return;
        }

        // Check clicks on objects
        const obj = getObjectAt(mx, my);
        
        if (obj) {
            target = { x: obj.x, y: obj.y }; // Go to object
            targetAction = { type: 'harvest', obj: obj };
            createEffect(mx, my, 'üéØ');
        } else {
            target = { x: mx, y: my };
            targetAction = null;
            createEffect(mx, my, 'üìç');
        }
    }

    function updatePhysics() {
        if (!target) return;

        const dx = target.x - player.x;
        const dy = target.y - player.y;
        const dist = Math.sqrt(dx*dx + dy*dy);
        const speed = 4;

        if (dist > speed) {
            player.x += (dx/dist) * speed;
            player.y += (dy/dist) * speed;
            player.facing = dx > 0 ? 1 : -1;
            player.anim = (Date.now() / 100) % Math.PI; // Walking anim
        } else {
            // Arrived
            player.x = target.x;
            player.y = target.y;
            target = null;
            
            if(targetAction) {
                performAction(targetAction);
                targetAction = null;
            }
        }
    }

    function performAction(act) {
        if(act.type === 'harvest') {
            const o = act.obj;
            // Add items
            if(o.type === 'tree') {
                addItem('wood', 3);
                addItem('berry', 1);
                toast('+3 –î–µ—Ä–µ–≤–∞');
                removeWorldObject(o);
            } else if (o.type === 'rock') {
                addItem('stone', 2);
                toast('+2 –ö–∞–º–Ω—è');
                removeWorldObject(o);
            }
        }
    }

    // --- INVENTORY SYSTEM ---
    function addItem(id, qty) {
        if(!player.inv[id]) player.inv[id] = 0;
        player.inv[id] += qty;
        saveGame();
    }

    function removeItem(id, qty) {
        if(player.inv[id] >= qty) {
            player.inv[id] -= qty;
            if(player.inv[id] <= 0) delete player.inv[id];
            return true;
        }
        return false;
    }

    function equipItem(id) {
        const def = ITEMS[id];
        if(!def.slot) return;
        
        // Unequip current if exists
        if(player.equip[def.slot]) {
            addItem(player.equip[def.slot], 1);
        }
        
        player.equip[def.slot] = id;
        removeItem(id, 1);
        renderInventory(); // refresh
        toast(`–ù–∞–¥–µ—Ç–æ: ${def.name}`);
    }

    function unequip(slot) {
        if(player.equip[slot]) {
            addItem(player.equip[slot], 1);
            player.equip[slot] = null;
            renderInventory();
        }
    }

    function useItem(id) {
        const def = ITEMS[id];
        if(def.type === 'food') {
            player.food = Math.min(100, player.food + def.val);
            removeItem(id, 1);
            toast('–ù—è–º-–Ω—è–º!');
            updateHUD();
            renderInventory();
        } else if (def.type === 'build') {
            startBuildMode(id);
            closeModals();
        }
    }

    // --- BUILDING ---
    function startBuildMode(id) {
        mode = 'build';
        buildItem = id;
        document.getElementById('build-hint').style.display = 'block';
        toast('–†–µ–∂–∏–º —Å—Ç—Ä–æ–π–∫–∏');
    }

    function placeStructure(mx, my) {
        // Snap to grid 
        const gx = Math.floor(mx / TILE_SIZE) * TILE_SIZE;
        const gy = Math.floor(my / TILE_SIZE) * TILE_SIZE;
        
        // Deduct item
        if(removeItem(buildItem, 1)) {
            world.structures.push({ x: gx, y: gy, id: ITEMS[buildItem].id });
            toast('–ü–æ—Å—Ç—Ä–æ–µ–Ω–æ!');
            
            if(!player.inv[buildItem]) {
                mode = 'play';
                document.getElementById('build-hint').style.display = 'none';
            }
            saveGame();
        }
    }

    // --- UI RENDER ---
    function openModal(type) {
        document.querySelectorAll('.modal').forEach(m => m.classList.remove('open'));
        document.getElementById('modal-' + type).classList.add('open');
        
        if(type === 'inventory') renderInventory();
        if(type === 'craft') renderCraft();
    }

    function closeModals() {
        document.querySelectorAll('.modal').forEach(m => m.classList.remove('open'));
    }

    function renderInventory() {
        const grid = document.getElementById('inv-grid');
        grid.innerHTML = '';
        
        // Show equipped items first? Or just list
        // Let's list equipped separately in future, now all in inv
        
        for(let id in player.inv) {
            const def = ITEMS[id];
            const el = document.createElement('div');
            el.className = 'slot';
            el.innerHTML = `<div>${def.icon}</div><div class="count">${player.inv[id]}</div>`;
            el.onclick = () => showInvDetails(id);
            grid.appendChild(el);
        }
    }

    function showInvDetails(id) {
        const d = document.getElementById('inv-details');
        const def = ITEMS[id];
        let html = `<b>${def.name}</b><br><small>${def.type.toUpperCase()}</small><br><div style="display:flex; gap:5px; margin-top:5px;">`;
        
        if(def.slot) html += `<button class="btn-action primary" onclick="equipItem('${id}')">–ù–∞–¥–µ—Ç—å</button>`;
        if(def.type === 'food') html += `<button class="btn-action primary" onclick="useItem('${id}')">–°—ä–µ—Å—Ç—å</button>`;
        if(def.type === 'build') html += `<button class="btn-action primary" onclick="useItem('${id}')">–°—Ç—Ä–æ–∏—Ç—å</button>`;
        
        html += `</div>`;
        d.innerHTML = html;
    }

    function renderCraft() {
        const grid = document.getElementById('craft-grid');
        grid.innerHTML = '';
        
        RECIPES.forEach((r, idx) => {
            const def = ITEMS[r.out];
            const el = document.createElement('div');
            el.className = 'slot';
            el.innerHTML = `<div>${def.icon}</div>`;
            
            // Check cost
            let can = true;
            for(let res in r.cost) if((player.inv[res]||0) < r.cost[res]) can = false;
            
            if(!can) el.style.opacity = '0.3';
            
            el.onclick = () => {
                const d = document.getElementById('craft-details');
                let costStr = Object.entries(r.cost).map(([k,v]) => `${ITEMS[k].icon}${v}`).join(' ');
                d.innerHTML = `<b>${def.name}</b><br>–¶–µ–Ω–∞: ${costStr}<br><button class="btn-action primary" ${!can?'disabled':''} onclick="craft(${idx})">–°–æ–∑–¥–∞—Ç—å</button>`;
            };
            grid.appendChild(el);
        });
    }

    function craft(idx) {
        const r = RECIPES[idx];
        // Deduct
        for(let res in r.cost) removeItem(res, r.cost[res]);
        // Add
        addItem(r.out, r.n);
        toast(`–°–æ–∑–¥–∞–Ω–æ: ${ITEMS[r.out].name}`);
        renderCraft(); // Refresh UI
    }

    function updateHUD() {
        document.getElementById('bar-hp').style.width = player.hp + '%';
        document.getElementById('bar-food').style.width = player.food + '%';
        document.getElementById('bar-water').style.width = player.water + '%';
    }

    function toast(msg) {
        const t = document.createElement('div');
        t.className = 'toast';
        t.innerText = msg;
        document.getElementById('toasts').appendChild(t);
        setTimeout(() => t.remove(), 2000);
    }

    function saveGame() {
        const data = { player, world };
        localStorage.setItem('surv_save_v1', JSON.stringify(data));
    }

    // --- RENDER ---
    function render() {
        resize();
        updatePhysics();

        // Camera Follow
        camera.x += (player.x - canvas.width/2 - camera.x) * 0.1;
        camera.y += (player.y - canvas.height/2 - camera.y) * 0.1;

        // BG
        ctx.fillStyle = '#2d3e26'; // Grass
        ctx.fillRect(0,0, canvas.width, canvas.height);

        // Draw World Objects
        const objects = getVisibleObjects(); // Proc gen + saved structures
        
        // Sort by Y
        objects.push({ type: 'player', x: player.x, y: player.y });
        objects.sort((a,b) => a.y - b.y);

        objects.forEach(o => {
            const sx = o.x - camera.x;
            const sy = o.y - camera.y;
            
            if(o.type === 'player') drawPlayer(sx, sy);
            else drawObject(sx, sy, o);
        });
        
        // Draw Build Preview
        if(mode === 'build' && target) {
             const gx = Math.floor(target.x / TILE_SIZE) * TILE_SIZE - camera.x;
             const gy = Math.floor(target.y / TILE_SIZE) * TILE_SIZE - camera.y;
             ctx.globalAlpha = 0.5;
             drawObject(gx, gy, {id: ITEMS[buildItem].id, type:'structure'});
             ctx.globalAlpha = 1.0;
        }

        requestAnimationFrame(render);
    }

    // Pseudo-random object generation based on coordinates
    function getVisibleObjects() {
        const res = [];
        // Add Saved Structures
        world.structures.forEach(s => {
            res.push({ type: 'structure', x: s.x, y: s.y, id: s.id });
        });

        // Generate Trees/Rocks around camera
        // Using simple grid hashing for stability
        const cx = Math.floor(camera.x / 100);
        const cy = Math.floor(camera.y / 100);
        
        for(let x = cx-1; x < cx + (canvas.width/100)+2; x++) {
            for(let y = cy-1; y < cy + (canvas.height/100)+2; y++) {
                // Pseudo random
                const val = Math.sin(x * 12.9898 + y * 78.233) * 43758.5453;
                const rand = val - Math.floor(val);
                
                // Check if structure exists here (simple collision check)
                const realX = x * 100 + 50;
                const realY = y * 100 + 50;
                const hasStruct = world.structures.some(s => Math.abs(s.x - realX) < 40 && Math.abs(s.y - realY) < 40);
                
                // Check if removed (chopped)
                const isRemoved = world.removed && world.removed.includes(`${realX}:${realY}`);
                
                if(!hasStruct && !isRemoved) {
                    if(rand > 0.7) res.push({ type: 'tree', x: realX, y: realY });
                    else if (rand < 0.1) res.push({ type: 'rock', x: realX, y: realY });
                }
            }
        }
        return res;
    }
    
    function removeWorldObject(o) {
        if(!world.removed) world.removed = [];
        world.removed.push(`${o.x}:${o.y}`);
        saveGame();
    }
    
    function getObjectAt(mx, my) {
        // Brute force check visible
        const objs = getVisibleObjects();
        return objs.find(o => Math.abs(o.x - mx) < 20 && Math.abs(o.y - my) < 20 && o.type !== 'player' && o.type !== 'structure');
    }

    // --- DRAWING ---
    function rect(x, y, w, h, c) { ctx.fillStyle = c; ctx.fillRect(x,y,w,h); }

    function drawObject(x, y, o) {
        const s = SCALE;
        if(o.type === 'tree') {
            rect(x-2*s, y-2*s, 4*s, 4*s, '#533');
            ctx.beginPath(); ctx.fillStyle = '#264'; ctx.arc(x, y-10*s, 8*s, 0, Math.PI*2); ctx.fill();
        } else if (o.type === 'rock') {
            ctx.beginPath(); ctx.fillStyle = '#777'; ctx.arc(x, y, 5*s, Math.PI, 0); ctx.fill();
        } else if (o.type === 'structure') {
            if(o.id === 101) rect(x, y-10*s, 16*s, 16*s, '#643'); // Wall
            if(o.id === 102) rect(x, y, 16*s, 16*s, '#432'); // Floor
            if(o.id === 103) { rect(x,y, 8*s, 2*s, '#555'); ctx.fillText('üî•', x-5, y); }
        }
    }

    function drawPlayer(x, y) {
        const s = SCALE;
        const bob = Math.sin(Date.now()/100)*2;
        
        // Body
        let chestC = '#dcb';
        if(player.equip.chest === 'shirt_rag') chestC = '#654'; // Brown rag
        
        rect(x-3*s, y-9*s+bob, 6*s, 7*s, chestC);
        rect(x-3*s, y-15*s+bob, 6*s, 6*s, '#dcb'); // Head
        rect(x-2*s, y-2*s, 2*s, 4*s, '#334'); // Legs
        rect(x+1*s, y-2*s, 2*s, 4*s, '#334');

        // Weapon
        if(player.equip.hand === 'axe_stone') {
             ctx.fillText('ü™ì', x+5*s, y-5*s+bob);
        } else if (player.equip.hand === 'sword_iron') {
             ctx.fillText('‚öîÔ∏è', x+5*s, y-5*s+bob);
        }
    }

    function resize() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        ctx.font = '16px monospace';
    }

    function createEffect(x,y,txt) {
        // simplified
    }

    init();
</script>
</body>
</html>
