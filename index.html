<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>SURVIVAL FIX 3.2</title>
    <script src="https://telegram.org/js/telegram-web-app.js"></script>
    <style>
        :root { --bg: #111; --panel: #1e1e1e; --border: #444; --accent: #f0a500; --text: #eee; }
        body { margin: 0; background: var(--bg); color: var(--text); overflow: hidden; font-family: 'Courier New', monospace; touch-action: none; user-select: none; }
        canvas { display: block; image-rendering: pixelated; width: 100%; height: 100%; }

        /* UI */
        .ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; }
        .pointer { pointer-events: auto; }

        /* HUD */
        .hud { position: absolute; top: 10px; left: 10px; display: flex; flex-direction: column; gap: 4px; width: 120px; z-index: 10; }
        .bar-wrap { background: #000; height: 8px; border: 1px solid #333; position: relative; }
        .bar-fill { height: 100%; transition: width 0.2s; }
        .c-hp { background: #d33; } .c-food { background: #fa0; } .c-water { background: #0af; }

        /* DOCK */
        .dock { position: absolute; bottom: 20px; left: 0; width: 100%; display: flex; justify-content: center; gap: 15px; pointer-events: auto; z-index: 10; }
        .dock-btn { 
            width: 50px; height: 50px; background: var(--panel); border: 2px solid var(--border); 
            border-radius: 8px; font-size: 24px; display: flex; justify-content: center; align-items: center; 
            box-shadow: 0 4px 6px rgba(0,0,0,0.5); cursor: pointer;
        }

        /* MODALS */
        .modal {
            display: none; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            width: 90%; max-width: 400px; max-height: 80%; background: var(--panel); 
            border: 2px solid var(--border); flex-direction: column; padding: 10px; border-radius: 4px; pointer-events: auto; z-index: 100;
        }
        .modal.open { display: flex; }
        .modal-header { display: flex; justify-content: space-between; border-bottom: 1px solid #444; padding-bottom: 5px; margin-bottom: 5px;}
        .grid { display: grid; grid-template-columns: repeat(5, 1fr); gap: 5px; overflow-y: auto; padding: 5px; }
        .slot { aspect-ratio: 1; background: #2a2a2a; border: 1px solid #333; display: flex; align-items: center; justify-content: center; position: relative; cursor: pointer; }
        .count { position: absolute; bottom: 2px; right: 2px; font-size: 10px; color: #aaa; }
        
        /* DETAILS & BUTTONS */
        .details { margin-top: 10px; border-top: 1px solid #444; padding-top: 5px; text-align: center; }
        .btn-action { background: var(--accent); border: none; padding: 5px 10px; color: #000; font-weight: bold; margin-top: 5px; cursor: pointer; }

        /* EMERGENCY RESET */
        #panic-btn {
            position: absolute; top: 10px; right: 10px; background: #f00; color: #fff; border: 1px solid #fff;
            padding: 5px; font-size: 10px; z-index: 9999; cursor: pointer; pointer-events: auto;
        }
        #error-log {
            position: absolute; top: 50%; left: 10%; width: 80%; color: red; background: rgba(0,0,0,0.8);
            font-size: 12px; pointer-events: none; z-index: 9000; word-wrap: break-word;
        }
        .toast { position: absolute; top: 60px; left: 50%; transform: translateX(-50%); background: rgba(0,0,0,0.8); padding: 5px; border-radius: 4px; animation: fade 2s forwards; }
        @keyframes fade { 0%{opacity:1} 100%{opacity:0; transform:translate(-50%, -20px)} }
    </style>
</head>
<body>

    <canvas id="game"></canvas>
    <div id="error-log"></div>
    <button id="panic-btn" onclick="hardReset()">–°–ë–†–û–° SAVE</button>

    <div class="ui-layer">
        <div class="hud">
            <div class="bar-wrap"><div class="bar-fill c-hp" id="bar-hp" style="width:100%"></div></div>
            <div class="bar-wrap"><div class="bar-fill c-food" id="bar-food" style="width:100%"></div></div>
            <div class="bar-wrap"><div class="bar-fill c-water" id="bar-water" style="width:100%"></div></div>
        </div>
        <div id="toasts"></div>
        
        <div class="dock">
            <div class="dock-btn" onclick="openInv()">üéí</div>
            <div class="dock-btn" onclick="openCraft()">üî®</div>
            <div class="dock-btn" onclick="saveGame(); toast('–°–æ—Ö—Ä–∞–Ω–µ–Ω–æ')">üíæ</div>
        </div>

        <div class="modal" id="main-modal">
            <div class="modal-header"><span id="m-title">...</span> <span onclick="closeModal()" style="color:#f44">‚úï</span></div>
            <div class="grid" id="m-grid"></div>
            <div class="details" id="m-details"></div>
        </div>
    </div>

<script>
    // --- ERROR HANDLING ---
    window.onerror = function(msg, url, line) {
        document.getElementById('error-log').innerHTML += `<br>Error: ${msg} line ${line}`;
    };

    function hardReset() {
        localStorage.removeItem('surv_save_v3_2');
        location.reload();
    }

    // --- DB ---
    const ITEMS = {
        'wood': { name: '–î–µ—Ä–µ–≤–æ', type: 'res', icon: 'üå≤' },
        'stone': { name: '–ö–∞–º–µ–Ω—å', type: 'res', icon: 'ü™®' },
        'meat': { name: '–ú—è—Å–æ', type: 'food', val: 20, icon: 'üçñ' },
        'leather': { name: '–ö–æ–∂–∞', type: 'res', icon: 'üìú' },
        'berry': { name: '–Ø–≥–æ–¥–∞', type: 'food', val: 10, water: 5, icon: 'üçí' },
        'axe': { name: '–¢–æ–ø–æ—Ä', type: 'tool', slot: 'hand', speed: 2, dmg: 4, icon: 'ü™ì' },
        'sword': { name: '–ú–µ—á', type: 'weapon', slot: 'hand', speed: 1, dmg: 10, icon: '‚öîÔ∏è' },
        'wall': { name: '–°—Ç–µ–Ω–∞', type: 'build', id: 101, icon: 'üß±' },
        'chest': { name: '–°—É–Ω–¥—É–∫', type: 'build', id: 200, icon: 'üì¶' }
    };

    const RECIPES = [
        { out: 'axe', n: 1, cost: {'wood':3, 'stone':2} },
        { out: 'sword', n: 1, cost: {'wood':5, 'stone':5} },
        { out: 'wall', n: 1, cost: {'wood':4} },
        { out: 'chest', n: 1, cost: {'wood':10} }
    ];

    // --- VARS ---
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const SCALE = 3; 
    const TILE = 16 * SCALE;
    
    let camera = { x: 0, y: 0 };
    let mode = 'play';
    let buildId = null;
    let activeCont = null;

    let player = { x: 0, y: 0, hp: 100, food: 100, water: 100, inv: {}, equip: {hand:null}, action: null };
    let world = { structures: [], containers: {}, removed: [], animals: [] };

    // --- INIT ---
    try {
        const save = localStorage.getItem('surv_save_v3_2');
        if(save) {
            const d = JSON.parse(save);
            player = d.player || player;
            world = d.world || world;
            // Patch data just in case
            if(!world.structures) world.structures = [];
            if(!world.containers) world.containers = {};
            if(!world.removed) world.removed = [];
            if(!world.animals) world.animals = [];
        }

        resize();
        window.addEventListener('resize', resize);
        canvas.addEventListener('pointerdown', input);
        
        if(world.animals.length === 0) spawnAnimals();

        requestAnimationFrame(loop);
        setInterval(tick, 1000);

    } catch(e) {
        document.getElementById('error-log').innerText = "INIT ERROR: " + e.message;
    }

    function resize() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        ctx.imageSmoothingEnabled = false;
    }

    function tick() {
        // Needs
        player.food -= 0.2; player.water -= 0.5;
        if(player.food<0) player.food=0; if(player.water<0) player.water=0;
        if(player.food===0 || player.water===0) player.hp -= 1;
        updateHUD();

        // Animals AI
        world.animals.forEach(a => {
            if(Math.random()<0.02) {
                a.tx = a.x + (Math.random()*100-50);
                a.ty = a.y + (Math.random()*100-50);
            }
            if(a.tx) {
                const dx = a.tx - a.x, dy = a.ty - a.y;
                const d = Math.sqrt(dx*dx+dy*dy);
                if(d>2) { a.x += (dx/d)*1; a.y += (dy/d)*1; }
                else a.tx = null;
            }
        });
    }

    function spawnAnimals() {
        for(let i=0; i<5; i++) {
            world.animals.push({ x: (Math.random()*1000)-500, y: (Math.random()*1000)-500, hp: 20, type: 'boar' });
        }
    }

    // --- INPUT ---
    function input(e) {
        const r = canvas.getBoundingClientRect();
        const mx = e.clientX - r.left + camera.x;
        const my = e.clientY - r.top + camera.y;

        if(mode === 'build') {
            build(mx, my);
            return;
        }

        const obj = getObj(mx, my);
        
        if(obj) {
            if(obj.type === 'chest') { openChest(obj.uid); return; }
            
            // Action
            const tId = player.equip.hand;
            let speed = 3000;
            if(tId && ITEMS[tId]) speed /= ITEMS[tId].speed;
            if(obj.type === 'animal') speed = 500;

            player.target = { x: obj.x, y: obj.y, stop: 30, cb: () => {
                player.action = { t: 0, max: speed, obj: obj, type: obj.type==='animal'?'atk':'mine' };
            }};
        } else {
            player.target = { x: mx, y: my, stop: 0 };
            player.action = null;
        }
    }

    function loop() {
        // Physics
        if(player.target) {
            const dx = player.target.x - player.x;
            const dy = player.target.y - player.y;
            const d = Math.sqrt(dx*dx + dy*dy);
            if(d > player.target.stop + 5) {
                const mx = (dx/d)*4, my = (dy/d)*4;
                if(!solid(player.x+mx, player.y+my)) {
                    player.x += mx; player.y += my;
                } else player.target = null;
            } else {
                if(player.target.cb) player.target.cb();
                player.target = null;
            }
        }

        if(player.action) {
            player.action.t += 16;
            if(player.action.t >= player.action.max) finishAct();
        }

        // Camera
        camera.x += (player.x - canvas.width/2 - camera.x) * 0.1;
        camera.y += (player.y - canvas.height/2 - camera.y) * 0.1;

        render();
        requestAnimationFrame(loop);
    }

    function solid(x, y) {
        // Simple collision
        return world.structures.some(s => s.id===101 && Math.abs(s.x-x)<20 && Math.abs(s.y-y)<20);
    }

    function finishAct() {
        const o = player.action.obj;
        player.action = null;
        if(o.type === 'tree') { addItem('wood', 3); addItem('berry', 1); rmObj(o); toast('+–î–µ—Ä–µ–≤–æ'); }
        if(o.type === 'rock') { addItem('stone', 2); rmObj(o); toast('+–ö–∞–º–µ–Ω—å'); }
        if(o.type === 'wall' && player.equip.hand === 'axe') { 
            rmStruct(o.uid); addItem('wood', 2); toast('–†–∞–∑–æ–±—Ä–∞–Ω–æ'); 
        }
        if(o.type === 'animal') {
            o.hp -= (player.equip.hand && ITEMS[player.equip.hand].dmg) || 2;
            toast(`Hit: ${o.hp}`);
            if(o.hp <= 0) {
                world.animals = world.animals.filter(a => a !== o);
                addItem('meat', 2); addItem('leather', 1);
                toast('–£–±–∏—Ç!');
            }
        }
        saveGame();
    }

    // --- SYSTEMS ---
    function addItem(id, n, cont) {
        const t = cont ? world.containers[cont].items : player.inv;
        t[id] = (t[id]||0) + n;
        updateHUD();
    }
    
    function build(mx, my) {
        const gx = Math.floor(mx/TILE)*TILE, gy = Math.floor(my/TILE)*TILE;
        if(solid(gx, gy)) return;
        
        if(player.inv[buildId] > 0) {
            player.inv[buildId]--;
            const uid = Date.now();
            world.structures.push({ x: gx, y: gy, id: ITEMS[buildId].id, uid: uid });
            if(ITEMS[buildId].id === 200) world.containers[uid] = { items: {} };
            toast('–ü–æ—Å—Ç—Ä–æ–µ–Ω–æ');
            if(player.inv[buildId] <= 0) { mode = 'play'; document.getElementById('main-modal').classList.remove('open'); }
            saveGame();
        }
    }

    function rmObj(o) { world.removed.push(`${o.x}:${o.y}`); }
    function rmStruct(uid) { 
        world.structures = world.structures.filter(s => s.uid !== uid); 
        delete world.containers[uid]; 
    }

    // --- UI ---
    function openInv() { renderModal('–†–Æ–ö–ó–ê–ö', player.inv); activeCont = null; }
    function openCraft() { 
        const g = document.getElementById('m-grid'); g.innerHTML = '';
        document.getElementById('m-title').innerText = '–ö–†–ê–§–¢';
        document.getElementById('main-modal').classList.add('open');
        RECIPES.forEach(r => {
            const el = document.createElement('div'); el.className='slot';
            el.innerHTML = ITEMS[r.out].icon;
            el.onclick = () => {
                // Craft logic inline for brevity
                let can = true;
                for(let k in r.cost) if((player.inv[k]||0)<r.cost[k]) can=false;
                if(can) {
                    for(let k in r.cost) player.inv[k] -= r.cost[k];
                    addItem(r.out, r.n);
                    toast('–°–∫—Ä–∞—Ñ—á–µ–Ω–æ!');
                    openCraft(); // redraw
                } else toast('–ú–∞–ª–æ —Ä–µ—Å—É—Ä—Å–æ–≤');
            };
            g.appendChild(el);
        });
        document.getElementById('m-details').innerHTML = '';
    }

    function openChest(uid) {
        activeCont = uid;
        renderModal('–°–£–ù–î–£–ö', world.containers[uid].items);
        // Append player items for transfer
        const g = document.getElementById('m-grid');
        const sep = document.createElement('div'); sep.style.gridColumn='1/-1'; sep.innerText='–†—é–∫–∑–∞–∫ ‚ñº'; g.appendChild(sep);
        for(let k in player.inv) {
            const el = document.createElement('div'); el.className='slot';
            el.innerHTML = `${ITEMS[k].icon}<div class="count">${player.inv[k]}</div>`;
            el.onclick = () => {
                if(player.inv[k] > 0) { player.inv[k]--; addItem(k, 1, uid); openChest(uid); }
            };
            g.appendChild(el);
        }
    }

    function renderModal(tit, src) {
        const g = document.getElementById('m-grid'); g.innerHTML = '';
        document.getElementById('m-title').innerText = tit;
        document.getElementById('main-modal').classList.add('open');
        for(let k in src) {
            if(src[k]<=0) continue;
            const el = document.createElement('div'); el.className='slot';
            el.innerHTML = `${ITEMS[k].icon}<div class="count">${src[k]}</div>`;
            el.onclick = () => {
                if(activeCont) {
                    // Take from chest
                    src[k]--; addItem(k, 1); openChest(activeCont);
                } else {
                    // Use/Equip
                    const d = document.getElementById('m-details');
                    const def = ITEMS[k];
                    d.innerHTML = `<b>${def.name}</b><br>`;
                    if(def.slot) d.innerHTML += `<button class="btn-action" onclick="player.equip['${def.slot}']='${k}'; toast('–ù–∞–¥–µ—Ç–æ'); closeModal()">–ù–ê–î–ï–¢–¨</button>`;
                    if(def.type==='food') d.innerHTML += `<button class="btn-action" onclick="player.inv['${k}']--; player.food+=20; toast('–ù—è–º'); openInv()">–°–™–ï–°–¢–¨</button>`;
                    if(def.type==='build') d.innerHTML += `<button class="btn-action" onclick="mode='build'; buildId='${k}'; closeModal(); toast('–°—Ç—Ä–æ–π!')">–°–¢–†–û–ò–¢–¨</button>`;
                }
            };
            g.appendChild(el);
        }
    }
    
    function closeModal() { document.getElementById('main-modal').classList.remove('open'); mode = 'play'; }
    function toast(msg) { const d=document.createElement('div'); d.className='toast'; d.innerText=msg; document.getElementById('toasts').appendChild(d); setTimeout(()=>d.remove(),2000); }
    function updateHUD() {
        document.getElementById('bar-hp').style.width=player.hp+'%';
        document.getElementById('bar-food').style.width=player.food+'%';
        document.getElementById('bar-water').style.width=player.water+'%';
    }
    function saveGame() { localStorage.setItem('surv_save_v3_2', JSON.stringify({player, world})); }

    // --- RENDER ---
    function render() {
        ctx.fillStyle = '#2d3e26'; ctx.fillRect(0,0, canvas.width, canvas.height);
        
        const objs = getObjs();
        objs.push({type:'player', x:player.x, y:player.y});
        objs.sort((a,b)=>a.y-b.y);

        objs.forEach(o => {
            const x = o.x - camera.x, y = o.y - camera.y;
            const s = SCALE;
            if(o.type==='player') {
                ctx.fillStyle='#dcb'; ctx.fillRect(x-9, y-27, 18, 21); // Body
                ctx.fillStyle='#334'; ctx.fillRect(x-6, y-6, 6, 12); ctx.fillRect(x+3, y-6, 6, 12); // Legs
                if(player.equip.hand) ctx.fillText(ITEMS[player.equip.hand].icon, x+15, y-15);
                // Action Bar
                if(player.action) {
                    ctx.fillStyle='#0f0'; ctx.fillRect(x-15, y-40, 30*(player.action.t/player.action.max), 4);
                }
            }
            else if(o.type==='tree') { ctx.fillStyle='#533'; ctx.fillRect(x-6, y-12, 12, 12); ctx.fillStyle='#264'; ctx.beginPath(); ctx.arc(x, y-30, 24, 0, 7); ctx.fill(); }
            else if(o.type==='rock') { ctx.fillStyle='#777'; ctx.beginPath(); ctx.arc(x, y, 15, 3.14, 0); ctx.fill(); }
            else if(o.type==='wall') { ctx.fillStyle='#643'; ctx.fillRect(x, y-30, 48, 48); }
            else if(o.type==='chest') { ctx.fillStyle='#853'; ctx.fillRect(x-15, y-15, 30, 24); ctx.fillText('üì¶', x-8, y+2); }
            else if(o.type==='animal') { 
                ctx.fillStyle='#532'; ctx.fillRect(x-15, y-15, 30, 18); 
                ctx.fillStyle='red'; ctx.fillRect(x-10, y-25, 20*(o.hp/20), 3);
            }
        });
    }

    function getObjs() {
        let res = [];
        world.structures.forEach(s => res.push({...s, type: s.id===101?'wall':'chest'}));
        world.animals.forEach(a => res.push({...a, type:'animal'}));
        
        const cx = Math.floor(camera.x/100), cy = Math.floor(camera.y/100);
        for(let x=cx-1; x<cx+5; x++) for(let y=cy-1; y<cy+8; y++) {
            const rx=x*100+50, ry=y*100+50;
            if(world.removed.includes(`${rx}:${ry}`)) continue;
            if(Math.sin(x*12+y*78)>0.7) res.push({type:'tree', x:rx, y:ry});
            else if(Math.sin(x*12+y*78)<-0.8) res.push({type:'rock', x:rx, y:ry});
        }
        return res;
    }
    
    function getObj(mx, my) {
        return getObjs().find(o => Math.abs(o.x-mx)<20 && Math.abs(o.y-my)<20 && o.type!=='player');
    }

</script>
</body>
</html>
