<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>POCKET SURVIVAL: BIOMES</title>
    <script src="https://telegram.org/js/telegram-web-app.js"></script>
    <style>
        body { margin: 0; background: #000; overflow: hidden; font-family: 'Courier New', monospace; touch-action: none; }
        canvas { display: block; image-rendering: pixelated; }
        
        /* UI LAYERS */
        .ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; }
        
        .panel { 
            background: rgba(20,20,20,0.85); border: 2px solid #444; 
            padding: 8px; pointer-events: auto; position: absolute; 
            color: #eee; font-size: 10px; backdrop-filter: blur(2px);
            border-radius: 6px;
        }

        /* NEEDS BARS */
        .needs-panel { top: 10px; left: 10px; width: 140px; }
        .stat-row { display: flex; align-items: center; margin-bottom: 4px; justify-content: space-between; }
        .stat-label { width: 30px; }
        .stat-track { flex: 1; height: 6px; background: #333; margin-left: 5px; border-radius: 3px; overflow: hidden; }
        .stat-fill { height: 100%; width: 100%; transition: width 0.5s; }
        
        /* COLORS */
        .c-hp { background: #d33; }
        .c-food { background: #fa0; }
        .c-water { background: #0af; }
        .c-temp { background: #f60; } /* Changes to cyan in winter */

        /* CONTROLS */
        .controls { bottom: 20px; right: 20px; display: flex; gap: 10px; }
        .btn { 
            width: 50px; height: 50px; background: #333; border: 2px solid #555; border-radius: 50%;
            display: flex; justify-content: center; align-items: center; font-size: 20px; cursor: pointer; pointer-events: auto;
        }
        .btn:active { background: #555; transform: scale(0.95); }
        .btn.toggle-on { border-color: #0f0; background: #242; }

        /* DEBUG/INFO */
        .biome-tag {
            position: absolute; top: 10px; right: 10px;
            padding: 5px 10px; background: rgba(0,0,0,0.5); border-radius: 20px;
            font-weight: bold; color: #fff; text-transform: uppercase;
        }
    </style>
</head>
<body>

    <canvas id="game"></canvas>

    <div class="ui-layer">
        <div class="panel needs-panel">
            <div class="stat-row"><span>HP</span> <div class="stat-track"><div class="stat-fill c-hp" id="bar-hp"></div></div></div>
            <div class="stat-row"><span>EDA</span> <div class="stat-track"><div class="stat-fill c-food" id="bar-food"></div></div></div>
            <div class="stat-row"><span>H2O</span> <div class="stat-track"><div class="stat-fill c-water" id="bar-water"></div></div></div>
            <div class="stat-row"><span>TMP</span> <div class="stat-track"><div class="stat-fill c-temp" id="bar-temp"></div></div></div>
        </div>

        <div class="biome-tag" id="biome-display">FOREST</div>

        <div class="controls">
            <div class="btn" onclick="toggleRaft()" id="btn-raft">üõ∂</div>
            <div class="btn" onclick="equipWeapon('rifle')">üî´</div>
            <div class="btn" onclick="equipWeapon('sword')">‚öîÔ∏è</div>
        </div>
    </div>

<script>
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const SCALE = 3; 
    const TILE_SIZE = 16 * SCALE; 
    const CHUNK_SIZE = 20; // tiles per chunk (optimization)

    // --- GAME STATE ---
    let camera = { x: 0, y: 0 };
    let gameTime = 0;

    const player = {
        x: 0, y: 0,
        vx: 0, vy: 0,
        speed: 4,
        target: null,
        state: 'idle',
        facing: 1,
        animTimer: 0,
        
        // Stats
        hp: 100,
        food: 100,
        water: 100,
        temp: 100, // 100 = warm, 0 = freezing
        
        // Equipment
        equip: { body: 'skin', chest: null, weapon: null },
        hasRaft: false
    };

    const objects = []; // {x, y, type, biome}

    // --- BIOME CONFIG ---
    // Forest (Center), Winter (North < -1000), Desert (South > 1000), Ocean (East > 1500)
    
    function getBiome(x, y) {
        if (x > 2000) return 'OCEAN';
        if (y < -1200) return 'WINTER';
        if (y > 1200) return 'DESERT';
        return 'FOREST';
    }

    const BIOMES = {
        'FOREST': { bg: '#2d3e26', tree: 'tree_oak', rock: 'rock_gray', part: 'üçÉ' },
        'WINTER': { bg: '#ddeeff', tree: 'tree_pine', rock: 'rock_ice', part: '‚ùÑÔ∏è' },
        'DESERT': { bg: '#eecd86', tree: 'cactus',    rock: 'rock_sand', part: '‚òÄÔ∏è' },
        'OCEAN':  { bg: '#1ca3ec', tree: 'none',      rock: 'none',      part: 'üåä' }
    };

    // --- INIT ---
    function init() {
        resize();
        window.addEventListener('resize', resize);
        canvas.addEventListener('pointerdown', handleInput);
        
        // Generate initial world around player
        generateChunk(0, 0);

        // Game Loops
        requestAnimationFrame(renderLoop);
        setInterval(logicLoop, 1000); // 1 sec tick for stats
    }

    function resize() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        ctx.imageSmoothingEnabled = false;
    }

    // --- GENERATION ---
    // Simple procedural generation based on coordinate hashing
    function generateChunk(cx, cy) {
        // Just fill objects randomly for now within a range if not exists
        for(let i=0; i<30; i++) {
            const rx = (Math.random() * 4000) - 2000; // -2000 to 2000
            const ry = (Math.random() * 4000) - 2000;
            const b = getBiome(rx, ry);
            
            if(b === 'OCEAN') continue; // Ocean needs islands (advanced logic later)

            let type = Math.random() > 0.3 ? 'tree' : 'rock';
            objects.push({ x: rx, y: ry, type: type, biome: b });
        }
        
        // Special: Ocean Islands
        for(let i=0; i<5; i++) {
             objects.push({ x: 2500 + Math.random()*1000, y: Math.random()*2000 - 1000, type: 'island', biome: 'OCEAN' });
        }
    }

    // --- LOGIC ---
    function logicLoop() {
        const b = getBiome(player.x, player.y);
        
        // Needs Decay
        player.food = Math.max(0, player.food - 0.5);
        player.water = Math.max(0, player.water - 0.8);

        // Biome Effects
        if(b === 'DESERT') {
            player.water = Math.max(0, player.water - 1.5); // Thirstier
            player.temp = Math.min(100, player.temp + 5); // Warm up
        } 
        else if (b === 'WINTER') {
            if(!player.equip.chest) player.temp = Math.max(0, player.temp - 2); // Freeze without clothes
        }
        else {
            player.temp = Math.min(100, player.temp + 1); // Normalize in forest
        }

        // Damage from stats
        if(player.food <= 0 || player.water <= 0 || player.temp <= 0) {
            player.hp = Math.max(0, player.hp - 2);
        } else {
            if(player.hp < 100 && player.food > 50) player.hp += 1; // Regen
        }

        updateUI(b);
    }

    function updateUI(biome) {
        const u = (id, val) => document.getElementById(id).style.width = val + '%';
        u('bar-hp', player.hp);
        u('bar-food', player.food);
        u('bar-water', player.water);
        u('bar-temp', player.temp);

        // Temp bar color
        const tBar = document.getElementById('bar-temp');
        if(biome === 'WINTER') tBar.style.backgroundColor = '#0ff'; // Cyan
        else tBar.style.backgroundColor = '#f60'; // Orange

        document.getElementById('biome-display').innerText = biome;
        
        const raftBtn = document.getElementById('btn-raft');
        if(player.hasRaft) raftBtn.classList.add('toggle-on');
        else raftBtn.classList.remove('toggle-on');
    }

    function handleInput(e) {
        const rect = canvas.getBoundingClientRect();
        const mx = e.clientX - rect.left + camera.x;
        const my = e.clientY - rect.top + camera.y;
        
        // Check Biome restrictions
        const targetBiome = getBiome(mx, my);
        if(targetBiome === 'OCEAN' && !player.hasRaft) {
            // Check if clicking on an island? (Simplified: just block water for now)
            // Allow clicking if close to edge? 
            // For prototype: Block movement if deep in water
             if (mx > 2100) { // Hard border for visual clarity
                 createEffect(mx, my, 'üö´');
                 return;
             }
        }

        player.target = { x: mx, y: my };
        createEffect(mx, my, 'üìç');
    }

    // --- RENDER ---
    function renderLoop() {
        // Physics
        if (player.target) {
            const dx = player.target.x - player.x;
            const dy = player.target.y - player.y;
            const dist = Math.sqrt(dx*dx + dy*dy);

            if (dist > player.speed) {
                player.state = 'run';
                player.animTimer += 0.2;
                player.x += (dx / dist) * player.speed;
                player.y += (dy / dist) * player.speed;
                player.facing = dx > 0 ? 1 : -1;
            } else {
                player.state = 'idle';
                player.target = null;
            }
        }

        // Camera
        camera.x += (player.x - canvas.width/2 - camera.x) * 0.1;
        camera.y += (player.y - canvas.height/2 - camera.y) * 0.1;

        // --- DRAWING ---
        // 1. Ground (Tile based optimization)
        const startCol = Math.floor(camera.x / 100) * 100;
        const startRow = Math.floor(camera.y / 100) * 100;
        
        for(let x = startCol; x < camera.x + canvas.width; x+=100) {
            for(let y = startRow; y < camera.y + canvas.height; y+=100) {
                const b = getBiome(x + 50, y + 50);
                ctx.fillStyle = BIOMES[b].bg;
                // Add some noise/texture variation
                ctx.fillRect(x - camera.x, y - camera.y, 102, 102); // Overlap slightly to fix gaps
            }
        }

        // 2. Objects
        // Sort by Y for depth
        const allObjs = [...objects, { ...player, type: 'player', y: player.y }];
        allObjs.sort((a, b) => a.y - b.y);

        allObjs.forEach(o => {
            const sx = o.x - camera.x;
            const sy = o.y - camera.y;
            // Optimization: cull off-screen
            if(sx < -100 || sx > canvas.width + 100 || sy < -100 || sy > canvas.height + 100) return;

            if(o.type === 'player') drawPlayer(sx, sy);
            else drawObject(ctx, sx, sy, o);
        });

        // 3. Effects
        drawEffects();

        requestAnimationFrame(renderLoop);
    }

    // --- ASSETS DRAWING ---
    function rect(ctx, x, y, w, h, c) { ctx.fillStyle = c; ctx.fillRect(Math.floor(x), Math.floor(y), w, h); }

    function drawObject(ctx, x, y, obj) {
        const s = SCALE;
        // Determine style based on Biome
        let colorMain = '#555';
        let colorDetail = '#333';
        const biomeData = BIOMES[obj.biome] || BIOMES['FOREST'];

        if (obj.type === 'tree') {
            if (obj.biome === 'WINTER') {
                // Pine Tree
                rect(ctx, x-2*s, y, 4*s, 4*s, '#433'); // Trunk
                rect(ctx, x-6*s, y-12*s, 12*s, 12*s, '#2a4a4a'); // Leaves Dark
                rect(ctx, x-4*s, y-12*s, 8*s, 4*s, '#ddeeff'); // Snow on top
            } else if (obj.biome === 'DESERT') {
                // Cactus
                rect(ctx, x-2*s, y-10*s, 4*s, 12*s, '#4a6'); // Main
                rect(ctx, x-5*s, y-6*s, 3*s, 3*s, '#4a6'); // Arm L
                rect(ctx, x+2*s, y-8*s, 3*s, 3*s, '#4a6'); // Arm R
            } else {
                // Oak
                rect(ctx, x-2*s, y-2*s, 4*s, 6*s, '#643');
                ctx.beginPath();
                ctx.fillStyle = '#362';
                ctx.arc(x, y-10*s, 8*s, 0, Math.PI*2);
                ctx.fill();
            }
        } else if (obj.type === 'rock') {
            let c = '#777';
            if(obj.biome === 'WINTER') c = '#aaccff';
            if(obj.biome === 'DESERT') c = '#aa8866';
            
            ctx.beginPath();
            ctx.fillStyle = c;
            ctx.arc(x, y, 5*s, Math.PI, 0);
            ctx.fill();
        } else if (obj.type === 'island') {
            ctx.beginPath();
            ctx.fillStyle = '#eecd86'; // Sand
            ctx.ellipse(x, y, 40*s, 20*s, 0, 0, Math.PI*2);
            ctx.fill();
            // Palm tree stub
            rect(ctx, x, y-10, 4, 10, '#543');
        }
    }

    function drawPlayer(x, y) {
        const s = SCALE;
        const bob = player.state === 'run' ? Math.sin(player.animTimer)*2 : 0;
        const f = player.facing;

        ctx.save();
        if(f === -1) { ctx.translate(x, y); ctx.scale(-1, 1); ctx.translate(-x, -y); }

        // RAFT (Under player)
        if(player.hasRaft && getBiome(player.x, player.y) === 'OCEAN') {
            rect(ctx, x-8*s, y+6*s, 16*s, 4*s, '#853');
        }

        // Shadow
        ctx.fillStyle = 'rgba(0,0,0,0.3)';
        ctx.beginPath(); ctx.ellipse(x, y+2*s, 6*s, 3*s, 0, 0, Math.PI*2); ctx.fill();

        // Legs
        const lOff = player.state === 'run' ? Math.sin(player.animTimer*2)*3 : 0;
        rect(ctx, x-2*s+lOff, y-2*s, 2*s, 4*s, '#223');
        rect(ctx, x+1*s-lOff, y-2*s, 2*s, 4*s, '#223');

        // Body
        let chestC = '#dcb'; // Skin
        if(player.equip.chest === 'armor') chestC = '#343'; // Armor
        rect(ctx, x-3*s, y-9*s+bob, 6*s, 7*s, chestC);

        // Head
        rect(ctx, x-3*s, y-15*s+bob, 6*s, 6*s, '#dcb');
        // Eyes
        rect(ctx, x+1*s, y-12*s+bob, 1*s, 1*s, '#000');
        // Hair/Hat
        rect(ctx, x-3*s, y-15*s+bob, 6*s, 2*s, '#432');

        // Weapon
        const wx = x + 3*s;
        const wy = y - 6*s + bob;
        if(player.equip.weapon === 'rifle') {
            rect(ctx, wx-2*s, wy, 12*s, 2*s, '#111'); // Gun
            rect(ctx, wx-3*s, wy, 2*s, 3*s, '#642'); // Stock
        } else if (player.equip.weapon === 'sword') {
             // Simple sword
             ctx.fillStyle = '#ccc';
             ctx.save();
             ctx.translate(wx, wy);
             ctx.rotate(Math.PI/4);
             ctx.fillRect(0, -8*s, 2*s, 10*s);
             ctx.restore();
        }

        ctx.restore();
    }

    // --- EFFECTS ---
    let effects = [];
    function createEffect(x, y, txt) { effects.push({x, y, txt, life: 30}); }
    function drawEffects() {
        ctx.font = "20px Arial";
        ctx.textAlign = "center";
        effects = effects.filter(e => e.life > 0);
        effects.forEach(e => {
            e.life--;
            ctx.fillStyle = `rgba(255,255,255,${e.life/30})`;
            ctx.fillText(e.txt, e.x - camera.x, e.y - camera.y - (30-e.life));
        });
    }

    // --- EXPORTS ---
    window.toggleRaft = () => {
        player.hasRaft = !player.hasRaft;
        const b = getBiome(player.x, player.y);
        updateUI(b); // refresh UI
    };
    window.equipWeapon = (w) => player.equip.weapon = w;

    init();
</script>
</body>
</html>
